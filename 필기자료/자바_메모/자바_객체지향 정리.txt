객체지향프로그래밍

생성자

1. 생성자란?
	- 연산을 위해서는 실제 메모리가 필요한데 이를 위해 인스턴스(객체)를
	생성하여 연산을 수행할 수 있게하는 메서드
	
2. 생성자 만들기
	- 생성자는 기본적으로 클래스를 만들때 기본 생성자가 함께 만들어 진다.
	- 기본 생성자는 컴파일러가 자동으로 정의한다.
	- 기본 생성자의 형태 : public void 클래스명(){}; 
	- 생성자를 따로 정의하면 기본 생성자는 정의되지 않는다.
	
3. 생성자 오버로드
	- 여러개의 생성자메서드를 만들기 위해 함수의 시그니쳐를 변경하는 것

4. 함수의 시그니쳐
	- 동일한 함수명을 갖더라도 서로 다른 메서드로 인식하게하는 요소
	- 시그니쳐 요소 : 반환값,매개변수,함수명 등 
	- 메서드 오버로드 : 시그니쳐 요소를 다르게 하여 다른 메서드로 정의
	
5. 기본 자료형을 제외한 모든 생성자는 참조 자료형이다.

-------------------------------------------------------------

정보은닉

1. 정보은닉이란?
	- 멤버변수는 통제가 불가능한 변수이기에 외부로부터 직접적인 접근을
	제한하고 값을 통제하기위해 getter(), setter() 를 사용하는 것

2. 접근제어자
	- public : 외부 패키지에서도 접근 가능
	- protected : 동일 패키지 접근가능 + 상속을 통해 외부패키지 접근가능
	- default : 동일 패키지 접근가능
	- private : 클래스 내부에서만 접근가능

3. getter(), setter()
	- private 변수의 통제를 위해 생성하는 메서드
	- 형태 : 
		get변수명() {
			return 멤버변수;
		}
		set변수명(멤버변수와 동일한 매개변수) {
			this.멤버변수 = 매개변수;
		}

4. this 예약어
	- 지역변수 this : 생성될 객체의 주소값을 가지고 있는 지역변수
	- 메서드 this() : 클래스 내부에서 사용 가능한 생성자 메서드
	- 일반적으로 해당 인스턴스의 주소값으로 사용된다.
	
-------------------------------------------------------------

동적메모리와 정적메모리

1. 동적메모리 : 메모리 중 스택,힙 영역에 해당
	- 메서드(스택), 생성된 인스턴스(힙) ...
	- this를 통해 접근가능

2. 정적메모리 : 메모리 중 데이터영역에 해당
	- final 상수, static 변수, static 메서드() , 리터럴상수....
	- 클래스명.변수나 클래스명.메서드로 직접접근 가능
	- this가 없으므로 인스턴스 자원을 호출불가

3. 변수의 종류
	- 지역변수 : 스택 영역, 메서드 연산 완료시 제거
	- 멤버변수(인스턴스 변수):힙 영역, 	가비지콜렉터(GC)가 수거 
	- static변수(클래스 변수):데이터 영역
		- static final 변수 = 클래스명.변수명으로 바로 접근가능
		- final 변수 = 생성자를 통해야 접근가능
		
4. static 응용 - 싱글톤 패턴
	- 일반적인 메서드의 경우 호출 때마다 객체를 생성하면 자원이 
	낭비되므로 동일한 객체를 계속 호출하는 형태의 패턴
	- 형태 :
	public class Singleton{
		private static Singleton instance;
		// private정적변수로 자기자신을 호출
		
		private Singleton() { };
		// 생성자는 private로 정의하여 외부호출 방지
		
		public static Singleton getInstance() {	// 객체반환 메서드 작성
			if(instance == null){
				instance = new Company();
				// 생성된 객체가 없으면 객체를 생성
			}
			return instance; 	// 객체를 반환
		}	
	}
	- 사용법 : Singleton.getInstance()을 호출하여 사용한다.
	
-------------------------------------------------------------

상속(extends)

1. 상속이란?
	- 다른 클래스의 자원을 가져와 사용함과 동시에 다형성을 부여하는 것

2. 다형성
	- 하위클래스가 상속한 상위클래스로 자동형변환 가능
	- 상위클래스가 하위클래스로는 명시적 형변환 필요
	- 하위클래스는 상위클래스를 포함하고 있다.

3. 형태
	- class 하위클래스 extends 상위클래스 {
		
	}
	
4. super예약어
	- super : 하위클래스에 자동생성되는 상위클래스의 객체주소를 가진 변수
	- super() : 상위클래스에 접근하는 생성자 메서드
	- 활용예시
		상속관계 : C <- B <- A  일 때,
		C()호출 -> C().super()=B() 호출 -> B().super():A() 호출 

5. 메서드 오버라이딩
	- 상위클래스와 동일한 메서드를 정의하여 사용하는 것
	- 활용예시
		상속관계 : B <- A  일 때,
		class B extends A {
			@Overring //상위클래스 메서드를 재정의함을 알리는 에노테이션
			public void A_method(){
				// 재정의할 코드
			}
		}
		- 이후 B의 생성자를 통해 재정의된 A_method()를 사용

-------------------------------------------------------------

추상클래스(abstract class)

1. 추상클래스란?
	- 구현체{}가 없는 추상메서드를 가진 클래스
	- 설계의 틀을 제공하고자 하는 클래스
	- java.io패키지에 정의되어 있다.
	- 일반 메서드와 변수도 정의가능
	- 다중 상속이 불가한다.(다수의 추상클래스를 상속 불가)

2. 추상클래스 형태
	public abstract class 클래스명 {
		추상메서드();
	}

3. 활용예시 : 인터페이스(interface)
	메서드모음 - 다양한 메서드를 
			메서드1
			메서드2
			메서드3
			메서드4(신규)
				메서드모음 변수명 = new 메서드;
				변수명.메서드1의 기능
				변수명.메서드2의 기능
				변수명.메서드3의 기능
				변수명.메서드4의 기능
				
-------------------------------------------------------------

인터페이스(interface)

1. 인터페이스란?
	- 추상클래스의 변형체
	- 추상메서드와 상수만 정의가능
	- 다중상속이 가능
	- 변수정의 시 public static final이 자동으로 붙는다.

2. 형태
	public interface 인터페이스명{
		public static 메서드();
	}

3. 활용예시
	상속관계 : C -> A,B 
	public class C implements A,B {
		A,B의 메서드를 재정의해서 사용
	}
	
-------------------------------------------------------------

내부 클래스 : 클래스안에 클래스를 정의하여 사용하는 방법

1. 인스턴스 내부 클래스

2. 정적 내부 클래스

3. 지역 내부 클래스