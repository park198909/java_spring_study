# 자바스크립트

## 함수
### 함수의 실행과정
global EC(전역 실행문맥 객체) 생성
	변수에 대한 구성
		-window의 하위 속성으로 추가됨
	외부함수 EC 변수 참조 링크 : null

	this바인딩(범위 결정) : window(확정된 값)

func1 EC(실행문맥 객체 - Execution Context) 생성
	변수에 대한 구성
		-원시타입 변수
			num1 : 10
		-참조타입 변수(객체)

	외부함수 EC 변수 참조 링크 : global EC

	this바인딩(범위 결정) : 호출한 객체(window)

func2 EC 생성
	변수에 대한 구성
		-원시타입 변수
			num2 : 20
	-참조타입 변수(객체)
		
	외부함수 EC 변수 참조 링크 : func1 EC
	
	this바인딩(범위 결정) : 호출한 객체(window)

*** 함수는 실행되면서 먼저 객체를 모두 생성(호이스팅) 하기 때문에 동일코드 안에서는 위아래 상관없이 인식된다. ***
*** 단, 호이스팅에서는 객체만 생성되기 떄문에 연산은 반영되지 않는다. 즉, 초기값(undefind)만 적용된다. ***
*** this는 함수가 실행될 때 확정된다. ***


### 함수 리터럴로 함수 정의하기 - 변수를 선언하고 함수를 대입하는 방식
var add = function(num1,num2){
    var result = num1+num2;
    return result;
};
*** 리터럴로 정의할 경우 실행 시 변수가 생성된 뒤에 동작 시에  함수가 적용되기 때문에 동일코드내 상위에서 함수사용이 불가하다.  ***


### 변수의 범위
var 	
	- 함수가 지역 범위, 함수가 아니면 변수의 값이 변경
	- 변수의 중복정의 가능 - 오류의 원인
let과const 
	- 지역 범위 -> {...}
	- 변수의 중복정의 불가
	- let은 변수 선언자 - 변하는 값
	- const는 상수 선언자 - 값을 변경X
	- const 변수명 = { 객체 };  -> "변수명.속성명 = 값"은 변수명(객체의 주소값)이므로 객체의 값들은 변경가능하다.
*** var자료형은 동일변수명으로 선언시 중요한 기존중복변수가 바뀌어 버리므로 let과const를 사용하도록 권장한다. ***
*** 단, let은 {}의 안과 밖을 구분짓는 방식이므로 {}밖에서는 중복정의가 되므로 변수는 const를 주로 사용한다. ***


즉시 실행 함수
( function(매개변수...){
	// 실행코드
} )(매개변수...);
- 매개변수
- 반환값

******


가변길이 인수 목록(Arguments 객체)
- 지연변수 arguments 객체 : 함수안에 기본적으로 생성되는 지역변수(매개변수를 자동으로 내부에 저장)
...변수명 : 가변매개변수
... -> 전개 연산자 : 변수 내 저장된 값을 모두 불러내어 매개변수로 사용한다
예)add(...nums); -> nums에 저장된 모든 값을 매개변수로 사용

******


생성자
- 함수 객체 == 일급 객체(first class Object)
- 함수객체를 통해 객체를 생성

생성자로 객체 생성하기
1. 생성자 함수 객체(객체 생성해주는 객체)
const 변수명 = new 생성자함수명(매개변수);
new 함수 호출 -> 객체 생성 -> 즉, new를 통해서 변수명의 함수객체를 생성하고 생성자함수를 상속시킨다.


*관례 : 생성자함수는 함수명 맨 앞을 대문자로 한다.

*** 
상속 : new를 통해 새로운 객체를 만드는 과정(상속->this범위변경 과정을 거친다,)
	[[Prototype]] 	 				//프로토타입 체인 - 상속관계를 나타낸다.
	-> 자바스크립트의 상속 : 프로토타입 체인을 연결함으로서 이뤄진다.
	-> 프로토타입체인을 연결하기 위해서 __proto__라는 속성을 사용한다.
	상속받을 객체.__proto__ = 상속할객체.prototype;      	// 프로토타입체인을 연결하는 행위                   
***

Function 생성자 객체를 통해 함수객체 생성
function 함수명(매개변수) {  };
	prototype
		함수를 호출
		.apply(thisArg["매개변수"...])
		.call(thisArg
		.bind(this,
function -> new Function(...) -> 상속의 과정(Function.prototype이 연결됨)


const p1 = new Person();
1) prototype 상속
p1.__proto__ = Person.prototype;

2) this의 범위를 p1로 변경하고 Person() 호출(초기화) -> Person()의 값을 참조하기위한 prototype.constructor값을 가져온다.
Person.call(p1);

*** 
생성자함수에 메서드를 만들 때는 함수가 생성될 때마다 복제되기 때문에 메모리 문제 해결을 위해 prototype내부에 기능을 구성하여 상속을 통해 사용하도록 한다.
***
*** 생성자함수에서 가장 중요한 것은 prototype이다.(생성자는 상속을 통해 객체를 생성하므로) ***


내장객체
자바스크립트 코어 - 자바 내 어디에도 존재하는 객체
	- 내장 생성자 객체
		Object : 모든 객체의 최상위에 존재하는 생성자객체(객체 생성시 기본으로 연결되어있는 객체)
		String
		- const str2 = str.concat("def") // new String(str).concat(...) -> str
	***원시타입에서 "래퍼생성자객체"로 자동치환 되어 사용할 수 있게되는 기능이 있다.***
	- 내장 객체
		Math, JSON...

호스트 객체 - 런타임 환경에 따른 객체 : 특정 환경에만 있는 객체들
(웹브라우저객체)
	window
		location
		history
		screen
		navigator
		document
		...

































